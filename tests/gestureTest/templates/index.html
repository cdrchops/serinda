<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Gesture Recognizer in Flask Template</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

    {#    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js" crossorigin="anonymous"></script>#}
    <style>
        body {
            font-family: roboto;
            margin: 2em;
            color: #3d3d3d;
            --mdc-theme-primary: #007f8b;
            --mdc-theme-on-primary: #f1f3f4;
        }
        h1 {
            color: #007f8b;
        }
        h2 {
            clear: both;
        }
        video {
            clear: both;
            display: block;
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
        }
        section {
            opacity: 1;
            transition: opacity 500ms ease-in-out;
        }
        .removed {
            display: none;
        }
        .invisible {
            opacity: 0.2;
        }
        .videoView,
        .detectOnClick {
            position: relative;
            float: left;
            width: 48%;
            margin: 2% 1%;
            cursor: pointer;
        }
        .videoView p,
        .detectOnClick p {
            padding-top: 5px;
            padding-bottom: 5px;
            background-color: #007f8b;
            color: #fff;
        }
        .canvas {
            z-index: 1;
            position: absolute;
            pointer-events: none;
        }
        .output_canvas {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            -moz-transform: rotateY(180deg);
        }
        .output {
            background-color: #fff;
            position: absolute;
            top: 0px;
            left: 0px;
            display: none;
            width: 100%;
            font-size: calc(8px + 1.2vw);
        }
    </style>
</head>
<body>
    <h1>Recognize Hand Gestures with MediaPipe (Client-Side)</h1>

    <section id="demos" class="invisible">
        <h2>Demo: Recognize Gestures in Images</h2>
        <p><em>Click on an image below</em> to identify gestures.</p>

        <div class="detectOnClick">
            <img src="https://assets.codepen.io/9177687/idea-gcbe74dc69_1920.jpg" crossorigin="anonymous" title="Click to recognize!" />
            <p class="classification removed"></p>
        </div>
        <div class="detectOnClick">
            <img src="https://assets.codepen.io/9177687/thumbs-up-ga409ddbd6_1.png" crossorigin="anonymous" title="Click to recognize!" />
            <p class="classification removed"></p>
        </div>

        <h2>Demo: Webcam Continuous Gesture Detection</h2>
        <p>Use your hand to make gestures in front of the camera. Click <b>enable webcam</b> and grant access.</p>

        <div id="liveView" class="videoView">
            <button id="webcamButton" class="mdc-button mdc-button--raised">
                <span class="mdc-button__ripple"></span>
                <span class="mdc-button__label">ENABLE WEBCAM</span>
            </button>
            <div style="position: relative;">
                <video id="webcam" autoplay playsinline></video>
                <canvas class="output_canvas" id="output_canvas" width="1280" height="720" style="position: absolute; left: 0px; top: 0px;"></canvas>
                <p id="gesture_output" class="output"></p>
            </div>
        </div>
    </section>

    <script>
        const { GestureRecognizer, FilesetResolver, DrawingUtils } = window;
        const demosSection = document.getElementById("demos");
        let gestureRecognizer;
        let runningMode = "IMAGE";
        let enableWebcamButton;
        let webcamRunning = false;
        const videoHeight = "360px";
        const videoWidth = "480px";

        const createGestureRecognizer = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numHands: 2
            });
            demosSection.classList.remove("invisible");
        };
        createGestureRecognizer();

        // Image detection demo
        const imageContainers = document.getElementsByClassName("detectOnClick");
        for (let i = 0; i < imageContainers.length; i++) {
            imageContainers[i].children[0].addEventListener("click", handleClick);
        }

        async function handleClick(event) {
            if (!gestureRecognizer) {
                alert("Please wait for gestureRecognizer to load");
                return;
            }
            if (runningMode === "VIDEO") {
                runningMode = "IMAGE";
                await gestureRecognizer.setOptions({ runningMode: "IMAGE" });
            }
            const allCanvas = event.target.parentNode.getElementsByClassName("canvas");
            for (let i = allCanvas.length - 1; i >= 0; i--) {
                allCanvas[i].parentNode.removeChild(allCanvas[i]);
            }
            const results = gestureRecognizer.recognize(event.target);
            if (results.gestures.length > 0) {
                const p = event.target.parentNode.childNodes[1];  // Adjusted index for p
                p.classList.remove("removed");
                const categoryName = results.gestures[0][0].categoryName;
                const categoryScore = (results.gestures[0][0].score * 100).toFixed(2);
                const handedness = results.handednesses[0][0].displayName;
                p.innerText = `Gesture: ${categoryName}\nConfidence: ${categoryScore}%\nHandedness: ${handedness}`;
                p.style = `left: 0px; top: ${event.target.height}px; width: ${event.target.width}px;`;

                const canvas = document.createElement("canvas");
                canvas.className = "canvas";
                canvas.width = event.target.naturalWidth;
                canvas.height = event.target.naturalHeight;
                canvas.style = `left: 0px; top: 0px; width: ${event.target.width}px; height: ${event.target.height}px;`;
                event.target.parentNode.appendChild(canvas);

                const ctx = canvas.getContext("2d");
                const drawingUtils = new DrawingUtils(ctx);
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawLandmarks(landmarks, { radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, .1, 5, 1) });
                    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS);
                }
            }
        }

        // Webcam detection demo
        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const gestureOutput = document.getElementById("gesture_output");

        function hasGetUserMedia() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        if (hasGetUserMedia()) {
            enableWebcamButton = document.getElementById("webcamButton");
            enableWebcamButton.addEventListener("click", enableCam);
        } else {
            console.warn("getUserMedia() is not supported by your browser");
        }

        function enableCam(event) {
            if (!gestureRecognizer) {
                alert("Please wait for gestureRecognizer to load");
                return;
            }
            webcamRunning = !webcamRunning;
            enableWebcamButton.innerText = webcamRunning ? "DISABLE PREDICTIONS" : "ENABLE PREDICTIONS";
            const constraints = { video: true };
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            });
        }

        let lastVideoTime = -1;
        let results = undefined;
        async function predictWebcam() {
            canvasElement.style.height = videoHeight;
            video.style.height = videoHeight;
            canvasElement.style.width = videoWidth;
            video.style.width = videoWidth;
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
            }
            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                results = gestureRecognizer.recognizeForVideo(video, nowInMs);
            }
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            const drawingUtils = new DrawingUtils(canvasCtx);
            if (results.landmarks) {
                for (const landmarks of results.landmarks) {
                    drawingUtils.drawLandmarks(landmarks, {
                        color: "#FF0000",
                        lineWidth: 2
                    });
                    drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                        color: "#00FF00",
                        lineWidth: 5
                    });
                }
            }
            canvasCtx.restore();
            if (results.gestures.length > 0) {
                gestureOutput.style.display = "block";
                gestureOutput.style.width = videoWidth;
                const categoryName = results.gestures[0][0].categoryName;
                const categoryScore = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                gestureOutput.innerText = `Gesture recognized: ${categoryName} (${categoryScore}%)`;
            } else {
                gestureOutput.style.display = "none";
            }
            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>
</html>