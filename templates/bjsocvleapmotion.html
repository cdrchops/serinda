<!--
Author: Wink Doubleguns
Purpose: Integrate OpenCV.js, LeapMotion, and BabylonJS - so OpenCV functions can be viewed in a Babylonjs GUI/HUD
Modified from https://github.com/BrightIdeaRealities/LeapMotionGame
Also modified from https://github.com/ericschv/opencvjs-webgl
-->
<!--
    Author: Austin Bearden
    Purpose: Control the Babylon ball like a hand
    Filename: handBall.html
    Final Submission Date: 04/23/2019 (April 23rd, 2019)
-->

<!--
  Built on top of Babylon.js standard tutorial found here: https://doc.babylonjs.com/
-->

<!--
Author: Austin Bearden
Date Created: 04/04/2019
Purpose: Get connect/info live from LeapMotion controller
Using code from: LeapMotion SDK: JSONViewer.html (https://developer-archive.leapmotion.com/documentation/v2/javascript/supplements/Leap_JSON.html#connecting-to-the-websocket-server)
Filename: connection.html
-->

<!-- Get LeapMotin Data -->
<!DOCTYPE html>
<!------------------------------------------------------------------------------
| Copyright (C) 2012-2013 Leap Motion, Inc. All rights reserved.               |
| Leap Motion proprietary and confidential. Not for distribution.              |
| Use subject to the terms of the Leap Motion SDK Agreement available at       |
| https://developer.leapmotion.com/sdk_agreement, or another agreement         |
| between Leap Motion and you, your company or other organization.             |
------------------------------------------------------------------------------->
<html>
<head>
    <title>OpenCV.js, BabylonJS, LeapMotion POC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bablyon links and CSS styling -->
    <!-- Link to the last version of BabylonJS -->
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <!-- Link to the last version of BabylonJS loaders to enable loading filetypes such as .gltf -->
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <!-- Link to pep.js to ensure pointer events work consistently in all browsers -->
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>

    <script src="/static/util.js"></script>
    <script async src="/static/haokingopencv.js"></script>
    <script src="/static/gl-matrix.js"></script>
    <script src="/static/webgl-video-cube.js"></script>

    <style>
        #renderCanvas {
            width: 640px;
            height: 480px;
            touch-action: none;
            opacity: 50%;
        }

        /* This is where the height and width of the image returning from the camera is set*/
        img {
            width: 640px;
            height: 480px;
        }

        #gamecontainer {
            border: 1px solid black;
            position: absolute;
            margin: 0 auto;
        }

        #gamestartscreen {
            position: absolute;
        }

        body {
            margin: 0;
        }

    </style>

    <script>
        var ws;
        var paused = false;
        var pauseOnGesture = false;
        var focusListener;
        var blurListener;
        // hand's palm position
        var palmPosX = 10;
        var palmPosY = 0;
        var palmPosZ = 3;
        var rotationValue = 0; //made this global variable for the sake of control bablyon object


        // Support both the WebSocket and MozWebSocket objects
        if ((typeof (WebSocket) == 'undefined') &&
            (typeof (MozWebSocket) != 'undefined')) {
            WebSocket = MozWebSocket;
        }

        //Babylon main script code
        window.addEventListener('DOMContentLoaded', function () {
            // All the following code is entered here.
            var canvas = document.getElementById('renderCanvas');
            var engine = new BABYLON.Engine(canvas, true);

            var createScene = function () {
                // Create a basic BJS Scene object.
                var scene = new BABYLON.Scene(engine);

                // Create a FreeCamera, and set its position to (x:0, y:5, z:-10).
                var camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 5, -10), scene);

                // Target the camera to scene origin.
                camera.setTarget(BABYLON.Vector3.Zero());

                // Attach the camera to the canvas.
                camera.attachControl(canvas, false);

                // Create a basic light, aiming 0,1,0 - meaning, to the sky.
                var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

                // Create a built-in "sphere" shape.
                var sphere = BABYLON.MeshBuilder.CreateSphere('sphere', {segments: 16, diameter: 2}, scene);

                // Initially set X, Y, Z position of Sphere
                sphere.position.x = palmPosX;
                sphere.position.y = palmPosY;
                sphere.position.z = -palmPosZ;

                // Create a built-in "ground" shape.
                // var ground = BABYLON.MeshBuilder.CreateGround('ground1', {height:6, width:6, subdivisions: 2}, scene);

                //adding plane for collision
                var plane = BABYLON.MeshBuilder.CreatePlane("plane", {width: 5, height: 5}, scene);

                engine.runRenderLoop(function () {
                    // Update X, Y, Z position of Sphere
                    sphere.position.x = palmPosY / 100;
                    sphere.position.y = palmPosY / 100;
                    sphere.position.z = -palmPosZ / 100;
                    //create methods for updating variables and call methods here!!
                    scene.render();
                });

                // Return the created scene.
                return scene;
            }

            var scene = createScene();

            window.addEventListener('resize', function () {
                engine.resize();
            });
        });

        // Create the socket with event handlers
        function init() {
            // Create and open the socket
            ws = new WebSocket("ws://localhost:6437/v6.json");

            // On successful connection
            ws.onopen = function (event) {
                var enableMessage = JSON.stringify({enableGestures: true});
                ws.send(enableMessage); // Enable gestures
                ws.send(JSON.stringify({focused: true})); // claim focus

                focusListener = window.addEventListener('focus', function (e) {
                    ws.send(JSON.stringify({focused: true})); // claim focus
                });

                blurListener = window.addEventListener('blur', function (e) {
                    ws.send(JSON.stringify({focused: false})); // relinquish focus
                });

                // document.getElementById("main").style.visibility = "visible";
                // document.getElementById("connection").innerHTML = "WebSocket connection open!";
            };

            // On message received
            ws.onmessage = function (event) {
                if (!paused) {
                    var obj = JSON.parse(event.data);
                    if (obj !== undefined && obj.hands !== undefined && obj.hands[0] !== undefined) {
                        //update palmPosX,Y,Z variable values from the JSON feed from the WebSocket
                        var objRotation = obj.hands[0].armBasis[1];
                        palmPosX = obj.hands[0].palmPosition[0]; // x-dimension of palm position
                        palmPosY = obj.hands[0].palmPosition[1]; // y-dimension of palm position
                        palmPosZ = obj.hands[0].palmPosition[2]; // z-dimension of palm position

                        console.log("PalmX: ", palmPosX);
                        console.log("PalmY: ", palmPosY);
                        console.log("PalmZ: ", palmPosZ);
                    }
                }
            };


            // On socket close
            ws.onclose = function (event) {
                ws = null;
                window.removeListener("focus", focusListener);
                window.removeListener("blur", blurListener);
                document.getElementById("main").style.visibility = "hidden";
                document.getElementById("connection").innerHTML = "WebSocket connection closed";
            }

            // On socket error
            ws.onerror = function (event) {
                alert("Received error");
            };
        }

        function togglePause() {
            paused = !paused;

            if (paused) {
                document.getElementById("pause").innerText = "Resume";
            } else {
                document.getElementById("pause").innerText = "Pause";
            }
        }

        function pauseForGestures() {
            if (document.getElementById("pauseOnGesture").checked) {
                pauseOnGesture = true;
            } else {
                pauseOnGesture = false;
            }
        }
    </script>
</head>

<body onload="init();">
<div class="gamecontainer" style="display:table-row;background-color:transparent;">
    <div id="gamestartscreen">
<!--        <img id="bg" src="{{ url_for('video_feed') }}"/>-->
        <div style="display: inline-block; text-align: center; display: none;z-index: -1">
            <video id="videoInput" width="640" height="480"></video>
        </div>
        <div style="display: inline-block; text-align: center; display: none;">
            <canvas id="arucoCanvasOutput" width="640" height="480"></canvas>
        </div>
        <div style="display: inline-block; text-align: center">
            <canvas id="webgl-draw" width="640" height="480"></canvas>
        </div>
    </div>
    <canvas id="renderCanvas"></canvas>
</div>

<!--<h1>Leap WebSocket JSON Viewer</h1>-->
<button id="pause" onclick="togglePause()">Pause</button>
<!--<input type="checkbox" id="pauseOnGesture" onclick="pauseForGestures()">Pause on gesture</input>-->
<!--<div id="connection">WebSocket not connected</div>-->
<!--<div id="main" style="visibility:hidden">-->
<!--    <h3>JSON Frame data:</h3>-->
<!--    <div id="output"></div>-->
<!--</div>-->
<script>
    let markerId, markerCorner, rvec, tvec, copyCorners;
    var front = false;
    let video = document.getElementById('videoInput');

    loadTextResource('/static/utils.js', function (err, obj) {
        if (err) {
            console.error(err);
        } else {
            var script = document.createElement('script');
            script.append(obj);
            document.body.appendChild(script);

            loadTextResource('/static/aruco-video.js', function (err, obj) {
                if (err) {
                    console.error(err);
                } else {
                    var script = document.createElement('script');
                    script.append(obj);
                    document.body.appendChild(script);
                }
            });
        }
    });

    function opencvReady() {
        // // document.getElementById('ready').innerText = 'OpenCV is ready';
        // if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        //   console.log("enumerateDevices() not supported.");
        //   return;
        // }
        //
        // // List cameras and microphones.
        // navigator.mediaDevices.enumerateDevices()
        //     .then(function(devices) {
        //       devices.forEach(function(device) {
        //         console.log(device.kind + ": " + device.label +
        //                     " id = " + device.deviceId);
        //       });
        //     })
        //     .catch(function(err) {
        //       console.log(err.name + ": " + err.message);
        //     });

        //'08aa77fb59af4253b772279ba3313708c459b35cc16e5b66d24e1b77526cfd91'
        var deviceId = 'f987dd7c8a8ddb5003176852f8bcb5254f9eac9b0c9e73b67a76373197b54f6d';//front facing camera
        //{ deviceId: deviceId }
        //{ facingMode: 'user' }
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false })
            .then(function (stream) {
                video.srcObject = stream;
                video.play();
                main();
            })
            .catch(function (err) {
                console.log("An error occurred! " + err);
            });
        runDemo();
    }

    const checkOpencv = setInterval(() => {
        // let mat1 = cv.matFromArray(3,3,cv.CV_32FC1,[1,2,3,4,5,6,7,8,9]);
        // let mat2 = cv.matFromArray(3,3,cv.CV_32FC1,[1,2,3,4,5,6,7,8,9]);
        // let dst = new cv.Mat();
        // cv.add(mat1, mat2, dst);
        // mat1.delete(), mat2.delete();
        // //Don't forget to delete cv.Mat when you don't want to use it any more.
        // console.log("dst::" + dst.data32F);//dst::2,4,6,8,10,12,14,16,18
        // if (cv.usingWasm) {
            opencvReady();
            clearInterval(checkOpencv);
        // }
    }, 500);
</script>
</body>
</html>
