<!-- https://grok.com/chat/d6861eaf-85ff-4e6a-92bf-e00fa0a121f5 -->
<!DOCTYPE html>
<html>
<head>
  <title>MediaPipe Distance Estimation</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
</head>
<body>
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output" width="640" height="480"></canvas>
  <p id="distance">Distance: Calculating...</p>

  <script>
    // Initialize MediaPipe Face Mesh
    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`,
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    // Calibrated focal length (determined from calibration step, in pixels)
    let focalLength = 1000; // Example: computed from calibration
    const eyeToEyeReal = 0.06; // 6 cm (0.06 meters) average eye-to-eye distance

    // Set up camera
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output');
    const canvasCtx = canvasElement.getContext('2d');
    const distanceDisplay = document.getElementById('distance');

    // Calibration function (run once with a marker or face at known distance)
    async function calibrate() {
      // Example: Measure eye-to-eye pixel distance at 1 meter
      const knownDistance = 1; // 1 meter
      const knownRealSize = eyeToEyeReal; // 6 cm
      // Assume pixel distance is measured (run detection once and log pixelDist)
      // For simplicity, this is a placeholder; replace with actual measurement
      const pixelDist = await measureEyeDistance();
      focalLength = (pixelDist * knownDistance) / knownRealSize;
      console.log(`Calibrated focal length: ${focalLength} pixels`);
    }

    // Measure eye-to-eye pixel distance
    async function measureEyeDistance(results) {
      if (!results.multiFaceLandmarks) return null;
      const landmarks = results.multiFaceLandmarks[0];
      // Indices 33 and 263 are outer eye corners in Face Mesh
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const pixelDist = Math.sqrt(
        Math.pow((leftEye.x - rightEye.x) * canvasElement.width, 2) +
        Math.pow((leftEye.y - rightEye.y) * canvasElement.height, 2)
      );
      return pixelDist;
    }

    // Process face mesh results and estimate distance
    async function onResults(results) {
      // Clear canvas
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          // Draw landmarks (optional, for visualization)
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {
            color: '#C0C0C070',
            lineWidth: 1,
          });

          // Calculate distance
          const pixelDist = await measureEyeDistance(results);
          if (pixelDist) {
            const distance = (focalLength * eyeToEyeReal) / pixelDist;
            distanceDisplay.textContent = `Distance: ${distance.toFixed(2)} meters`;
          }
        }
      } else {
        distanceDisplay.textContent = 'Distance: No face detected';
      }

      canvasCtx.restore();
    }

    faceMesh.onResults(onResults);

    // Start webcam
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 640,
      height: 480,
    });
    camera.start();

    // Run calibration (uncomment to calibrate with a known distance)
    // calibrate();
  </script>
</body>
</html>