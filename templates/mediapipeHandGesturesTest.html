<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline MediaPipe Hands</title>
    <!-- Load the local MediaPipe bundle -->
    <script src="{{ url_for('static', filename='js/vision_bundle.js') }}" type="text/javascript" charset="utf-8"></script>
</head>
<body>
    <h1>Offline Hand Landmarker</h1>
    <video id="webcam" style="display:none;"></video>
    <canvas id="output_canvas"></canvas>

    <script type="text/javascript">
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const ctx = canvas.getContext('2d');
        const { HandLandmarker, FilesetResolver } = MediaPipeTasksVision;

        let handLandmarker;
        let runningMode = 'VIDEO';
        let lastVideoTime = -1;

        // Function to create the Hand Landmarker
        async function createHandLandmarker() {
            // Use the local WASM files
            const vision = await FilesetResolver.forVisionTasks(
                "{{ url_for('static', filename='js/wasm') }}"
            );

            // Use the local .task model file
            handLandmarker = await HandLandmarker.createFromModelPath(vision, "{{ url_for('static', filename='../hand_landmarker.task') }}");

            handLandmarker.setOptions({
                runningMode: runningMode,
                numHands: 2,
            });
            console.log("Hand Landmarker created successfully.");

            // Start webcam after model is loaded
            startWebcam();
        }

        // Function to start the webcam
        async function startWebcam() {
            if (navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    predictWebcam();
                });
            }
        }

        // Main prediction loop
        async function predictWebcam() {
            if (runningMode === 'IMAGE') {
                return;
            }

            const nowInMs = Date.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                // Get detection results
                const detections = handLandmarker.detectForVideo(video, nowInMs);
                drawResults(detections);
            }

            // Continuously predict hands
            window.requestAnimationFrame(predictWebcam);
        }

        // Draw landmarks on the canvas
        function drawResults(detections) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (detections.landmarks && detections.landmarks.length > 0) {
                for (const landmarks of detections.landmarks) {
                    // Draw the landmarks (circles)
                    for (const landmark of landmarks) {
                        ctx.beginPath();
                        ctx.arc(landmark.x * canvas.width, landmark.y * canvas.height, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    }

                    // Draw the connections (lines)
                    const connections = [
                        [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
                        [0, 5], [5, 6], [6, 7], [7, 8],       // Index finger
                        [5, 9], [9, 10], [10, 11], [11, 12], // Middle finger
                        [9, 13], [13, 14], [14, 15], [15, 16], // Ring finger
                        [0, 17], [17, 18], [18, 19], [19, 20], // Pinky finger
                        [0, 5], [9, 13], [13, 17]             // Palm base
                    ];

                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = 2;
                    for (const connection of connections) {
                        const start = landmarks[connection[0]];
                        const end = landmarks[connection[1]];
                        ctx.beginPath();
                        ctx.moveTo(start.x * canvas.width, start.y * canvas.height);
                        ctx.lineTo(end.x * canvas.width, end.y * canvas.height);
                        ctx.stroke();
                    }
                }
            }
        }

        // Initialize the landmarker when the window loads
        window.addEventListener('load', createHandLandmarker);
    </script>
</body>
</html>
